<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title> Lord Julus 'Anti-debugging in Win32' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Author" content="Lord Julus"/>
<meta name="KeyWords" lang="en" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, Lord Julus,Anti-debugging in Win32, data, start, delta, code, process, push, names, address, xxxxxxxx, handle, section, running, isdebuggerpresent, check, anti"/>
<meta name="Description" content="I am almost ashamed to open this subject here, but it has to be done. I  am  ashamed  not  actually  about  writing  it,  but  I am ashamed of the anti-virus  companies' shame. Because it *IS* a shame not to have after such a  long time something which you could call a real Win32 emulator. And don't jump  on me because it is true... Each and every win32 virus I wrote and you see  in  this  issue  was  not  discovered at first sight by any AV. After a little  work  on them, some smart AVs like AVP and DrWeb started to discover them...  It  was  only a matter of adding more laywers of encryption and all was  hidden  completely.  However,  even  if the fond of the article doesn't really exist (there is *NO* av that would act like good old TBAV in Dos), we must  start talking about this, because there is not so long until the AVers will start taking this seriously and programm some real code emulators."/>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"047a5bcbf67431883fc9ed25fba33612",petok:"3d2dd06c26116b53e7273263b26fbfbd6c6c5e6e-1498757965-1800",zone:"vxheaven.org",rocket:"a",apps:{}}];document.write('<script type="text/javascript" src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=85b614c0f6/cloudflare.min.js"><'+'\/script>');}}catch(e){};
//]]>
</script>
<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="/style.css"/><link rel="canonical" href="http://vxheaven.org/lib/vlj05.html"/>
<script type="text/rocketscript" data-rocketsrc="https://apis.google.com/js/plusone.js">{"parsetags": "explicit"}</script>
</head>
<body bgcolor="#dbc8a0" text="#302000" link="#225599" vlink="#113366">
<div class="s1">
<div style="float:right;"><a href="/lib/index.php?tbs=1"><img src="/img/max.gif" alt="Maximize"/></a></div> <form id="lf" style="margin: 0; float: right;" method="get" action="/index.php"><input type="hidden" name="action" value="set"/><select name="lang" onchange="javascript:document.getElementById('lf').submit();"><option value="ru">Русский</option><option selected="selected" value="en">English</option><option value="ua">Українська</option><option value="de">Deutsch</option><option value="es">Español</option><option value="fr">Fran&ccedil;ais</option><option value="it">Italiano</option><option value="pl">Polski</option></select></form>
<div style="float: right;"><div id="plusone"></div></div>
<script type="text/rocketscript">gapi.plusone.render("plusone", {"size":"small","count":"true"});</script>
<div style="float: right;" class="addthis_toolbox addthis_default_style">
<script type="text/rocketscript">var addthis_config = { ui_click: true }</script>
<a style="text-decoration: none; font-size: 10pt;" href="/?action=addthis" class="addthis_button_compact">Bookmark</a>
<script type="text/rocketscript" data-rocketsrc="http://s7.addthis.com/js/250/addthis_widget.js#username=herm1t"></script>
</div>
<div style="float: right;">
<script type="text/rocketscript" data-rocketsrc="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
<form action="/search.php" id="cse-search-box">
<input type="hidden" name="cx" value="002577580816726040001:z9_irkorydo"/>
<input type="hidden" name="cof" value="FORID:10"/>
<input type="hidden" name="ie" value="UTF-8"/>
<input type="text" name="q" size="12" value=" "/>
<input type="submit" name="sa" value="Search"/>
</form>
</div><h1><a href="/" style="text-decoration: none; color: #000000;">VX Heaven</a></h1>
<span class="nav"><a href="/lib/">Library</a> <a href="/vl.php">Collection</a> <a href="/src.php">Sources</a> <a href="/vx.php?id=eidx">Engines</a> <a href="/vx.php?id=tidx">Constructors</a> <a href="/vx.php?id=sidx">Simulators</a> <a href="/vx.php?id=uidx">Utilities</a> <a href="/links.php">Links</a> <a href="/donate.php" style="color: #706020" id="donate">Donate</a> <a href="/forum" style="text-decoration: underline;">Forum</a> </span><br clear="all"/>
</div>
<div class="s2"><h1>Anti-debugging in Win32</h1><p><a href="/lib/?lang=en&amp;author=Lord%20Julus"> Lord Julus</a><br/> <em> 1999</em></p><script type="text/rocketscript">var disqus_url = 'http://vxheaven.org/lib/vlj05.html';</script>[<a style="" href="/lib/?lang=EN&amp;index=AA#vlj05">Back to index</a>] [<a href="/lib/vlj05.html#disqus_thread">Comments</a>]<br/> 
<p> I am almost ashamed to open this subject here, but it has to be done. I am ashamed not actually about writing it, but I am ashamed of the anti-virus companies' shame. Because it *IS* a shame not to have after such a long time something which you could call a real Win32 emulator. And don't jump on me because it is true... Each and every win32 virus I wrote and you see in this issue was not discovered at first sight by any AV. After a little work on them, some smart AVs like AVP and DrWeb started to discover them... It was only a matter of adding more laywers of encryption and all was hidden completely. However, even if the fond of the article doesn't really exist (there is *NO* av that would act like good old TBAV in Dos), we must start talking about this, because there is not so long until the AVers will start taking this seriously and programm some real code emulators.</p>
<p> So, I guess you understood that this article will also be about anti emulation, not only anti-debugging.</p>
<p> First, let us note that the Win32 viruses need the Apis. They search the Apis using specific searching methods and save their addresses in different places in the memory. A call to an api, therefore, will look like this when unassembled:</p>
<pre class="source">jmp dword ptr [xxxxxxxx]</pre>
<p> And at address [xxxxxxxx] you have the saved address of the api inside the kernel body.</p>
<p> From the beginning this causes the code to be pretty uncomprehsible at first sight. A diassembler should locate all calls of the type above and then retrieve the addresses of the apis, and then scan the kernel, or other DLL's export section to locate the name of the api. Only after doing so, the person who disassembles your code could understand what it does and take action depending on the returned values.</p>
<p> Of course, we are not here to speak about fighting the human enemy. After all, any virus can be finally unassembled and understood. I will speak more on the automatical emulation and scanning.</p>
<p> Think of that... The AV is trying to 'see' what is your code going to do. So, one of the very first methods that comes to mind, and which has a lot of strength under Win32 would be the debugging. The Win32 systems allows one process to debug another process. However, this automatically sets a flag and the escape is quite obvious. All one needs to do is run the following api like this:</p>
<pre class="source">
        call [ebp+_IsDebuggerPresent]
        or eax, eax
        jz exit
        ...</pre>
<p> The name of the api is more than obvious. It returns 0 if the process is not debugged and non-zero if it is debugged. If a non-zero value is returned, it means that the running process is debugged.</p>
<p> Anyhow, as well as the human, the machine could look up each call somewhere inside a DLL body, scan it's export table and compare with some known names. For example, the AV might notice that a call is made to the api IsDebuggerPresent, and it might override the answer, or fake it. This is why we need to hide better the calls to the Apis. One idea that I had was to change them into some sort of redirector, which would simulate an import table. Something like this, for example:</p>
<pre class="source">
        call isdebuggerpresent
        ...
 isdebuggerpresent:
        jmp dword ptr [_isdebuggerpresent]
        ...
 _isdebuggerpresent dd 0
</pre>
<p> When you retrieve the apis addresses, you put the address of the IsDebuggerPresent api address in the _isdebuggerpresent place. But, remember that in viruses we use the delta handle. The jump will not point in the right direction unless you do a little trick... Assumming that your jumps are into an array like this:</p>
<pre class="source">
        jmp dword ptr [api1]
        jmp dword ptr [api2]
        ...
</pre>
<p>each jmp gets compiled like this:</p>
<pre class="source">0E9 xx xx xx xx</pre>
<p> So, all you need to do is go down the array and increment each address with the value of the delta. In this way, the jumps will point the right data.</p>
<p> Anyhow, the entire IsDebuggerPresent example gets compiled like this:</p>
<pre class="source">
        call xxxxxxxx

 xxxxxxxx: jmp [yyyyyyyy]

 yyyyyyyy  dd aaaaaaaa
</pre>
<p> So, you see, this looks exactly like a real import table addressing type. This is a much trickier way of calling the Apis and this could still fool many AVs.</p>
<p> Another very important thing is to avoid the usual. This is kind of redundant to say, as any original thing has a lower rate of disclosure, but I feel like I would at least emphasize it a little.</p>
<p> Let's see what became usual in the Win32 viruses:</p>
<ol>
<li>Checking for 'MZ' and 'PE'
<p>The usual checks are:</p>
<pre class="source">
	cmp word ptr [...], 'ZM'
	cmp word ptr [...], 'EP' (dword ptr [...], 00004554)
</pre>
<p> Please, avoid this! It flags most AV's. This kind of check is used whenever the virus tries to locate the kernel32 or check for a PE file validity. Use strange methods like these:</p>
<pre class="source">
                mov ax, word ptr [...]
                xor ax, 1234h
                cmp ax, 'ZM' xor 1234h
</pre></li>
<li>Api names list
<p>A list with Api names could be suspicious, if not inside the import or export section. Guard the api names like this, for example:</p>
<pre class="source">
 _CreateFileA db 'C'+1,'r'+1,'e'+1,'a'+1,'t'+1,'e'+1,\
                 'F'+1,'i'+1,'l'+1,'e'+1,'A+1
</pre>
<p> Before searching for api names, be sure to decrease each byte in the api name to obtain the real name. But on disk the above definition will look like this:</p>
<pre>
        "DsfbufGjmfB"
</pre>
<p>...Pretty annoying, huh?</p></li>
</ol>
<p> Another trick, but which could be useless on good debuggers could be the next one. This is a little piece of code which sets to 0 all debugger registers by generating the Mov DRx, eax instruction and calling it:</p>
<pre class="source">
       lea esi, drs             ; point Debug Registers opcodes
       mov ecx, 7               ; 7 registers
       lea edi, bait            ; point the opcode place
                                ;
 repp:                          ;
       lodsb                    ; take the opcode
       mov byte ptr [edi], al   ; generate instruction
       call zapp                ; call it!
       loop repp                ; do it again
       jmp finish               ;
                                ;
 zapp:                          ;
       xor eax, eax             ; eax = 0
       dw 230fh                 ; This turns to mov DRx, eax
 bait label                     ;
       db 0                     ;
       ret                      ;
                                ;
 drs db 0c0h, 0c8h, 0d0h, 0d8h, 0e8h, 0f0h, 0f8h ; debug registers opcodes
</pre>
<p> Yet, another interesting trick is using the SEH handler to make jumps. The idea is to set a quick set handler and then generate an instruction that causes a protection fault. The default SEH handler is the one of the running process. If the running process is trying to step by step our virus, the temporary SEH frame of the virus will not be actualy activated, so the protection fault will not make the code fall in the virus, where it should, but instead the AV will freeze after meeting the exception error and abort. Here is an example:</p>
<pre class="source">
        lea eax, ContinueCode              ; Set up a the
        push eax                           ; SEH handler
        push fs:[0]                        ;
        mov fs:[0], esp                    ;
                                           ;
        xor eax, eax                       ; This causes a page write fault
        mov [eax], 100h                    ; error
                                           ;
        jmp Quit                           ;
                                           ;
                                           ;
 ContinueCode:                             ; we come here if the error
        mov esp, [esp+8]                   ; happened
        pop fs:[0]                         ; Restore SEH frame
        add esp, 4                         ; restore stack
        ...

 Quit:  ...-> return to host
</pre>
<p> So, using the SEH handler we jump to the ContinueCode label. If the error doesn't occure for some reason, the code quits.</p>
<p> This brings us to hiding another thing: the SEH frame setup. If the AV understands that your code sets up a SEH frame, it might set up a breakpoint there and still trap your code. So, choose alternate ways of setting up the SEH frame. Here are some:</p>
<p> Normal way:</p>
<pre class="source">
        lea eax, ContinueCode              ; Set up a the
        push eax                           ; SEH handler
        push fs:[0]                        ;
        mov fs:[0], esp                    ;
</pre>
<p> Altenate way example:</p>
<pre class="source">
        mov ecx, -100h
        push fs
        pop es
        mov eax, 12345678h
        push eax
        lea eax, ContinueCode
        mov dword ptr [esp-4], eax
        mov ebx, es:[100h+ecx]
        push ebx
        mov eax, [esp]
        mov ebx, [eax]
        mov es:[100h+ecx], eax
</pre>
<p> Even if it looks ugly, unoptimized and all, it achives it's goal: it sets a SEH frame to point to ContinueCode and still, it doesn't look a bit like the normal way. You could even consider making it polymorphic.</p>
<p> And now, a really neat and cool idea would be the next one. I have to be honest with you, I didn't even have time to try it for the moment, but at least if you think about it, it's half done...</p>
<p> The idea goes like this... All win32 viruses keep their data close to the code area and it is normal to be so. Therefore, the flags on the section that the code runs in, should have the READ set (to be able to execute) and WRITE set (to be able to alter the variables' values). What if we would try to change all that? Here is how:</p>
<p> First of all, define your virus very well, like this:</p>
<pre class="source">
        code section

                code_start:
                            ...
                code_end

                data_start:
                            ...
                data_end

        end virus
</pre>
<p> Then think of two delta handles. Whenever you are accessing data from the data part use the first delta handle, and whenever you need to access a value from the code part, use the second delta handle (this situation will occur usualy only when you need the address of some routines, or when generating a poly decryptor). Note that data that only requires reading can also be put in the code section.</p>
<p> Then, when your virus infects its victim, it should add two sections one after the other, like this:</p>
<pre class="source">
        .mycode
           (code)
        .mydata
           (data)
</pre>
<p> The size of the first section is simple to compute. It's the size of the section padded to memory alignment. How to calculate the first delta handle, needed to access the data? Look:</p>
<pre class="source">
        start_of_code:
           call get_delta

        get_delta:
           pop ebp
           sub ebp, offset get_delta
           add ebp, alignment_difference
</pre>
<p> To get the alignment difference, simply locate the last section's raw data start and then substract the before last section's raw data start and also the size of code:</p>
<pre class="source">
        Alignment_difference = data_raw_start - code_raw_start - code_size
</pre>
<p> To compute the raw data addresses is too simple and I will not explain again (check the pe file layout article).</p>
<p> Now, everytime you want to access a data you simply use this:</p>
<pre class="source">
                mov register, [ebp+address]
</pre>
<p> For the code addressing you calculate another delta handle which you put, let's say in the ESI register. When you want to use the address of some procedure you do this:</p>
<pre class="source">
                lea register, [esi+address]
</pre>
<p> So, what do we have here? We have a virus lying in two sections!! And most important, the code section doesn't need to have the Write flag set. You can trust me this will pose a LOT of problems to the AVs...</p>
<p> Well, these would some small ideas on the Win32 guard up against AV attack, but I am sure that in the future we shall have to have better new methods as the AV industry will grow more and more.</p>
<p> Hope you enjoyed this, and if the two sections stuff works, please tell me ;-)</p>
[<a style="" href="/lib/?lang=EN&amp;index=AA#vlj05">Back to index</a>] [<a href="/lib/vlj05.html#disqus_thread">Comments</a>]<br/> <div id="disqus_thread"></div>
<script type="text/rocketscript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'vxheaven'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="/agreement.php">Terms of Use</a>!</small> <small>vxheaven.org aka vx.netlux.org</small></div>
<div style="margin-top: 2px; float: left;" class="adsapeu">
<script type="text/rocketscript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script>
</div>
<script data-rocketsrc="http://www.google-analytics.com/urchin.js" type="text/rocketscript"></script><script type="text/rocketscript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="/lib/index.php?lang=de&amp;id=vlj05">de</a><a href="/lib/index.php?lang=en&amp;id=vlj05">en</a><a href="/lib/index.php?lang=es&amp;id=vlj05">es</a><a href="/lib/index.php?lang=it&amp;id=vlj05">it</a><a href="/lib/index.php?lang=fr&amp;id=vlj05">fr</a><a href="/lib/index.php?lang=pl&amp;id=vlj05">pl</a><a href="/lib/index.php?lang=ru&amp;id=vlj05">ru</a><a href="/lib/index.php?lang=ua&amp;id=vlj05">ua</a></div>
</body>
</html>
